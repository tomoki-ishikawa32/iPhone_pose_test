<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>iPhone Pose Swing Clip</title>
  <style>
    :root { --radius: 14px; --pad: 12px; }

    body {
      font-family: -apple-system, system-ui, sans-serif;
      margin: 0;
      padding: 12px 12px calc(150px + env(safe-area-inset-bottom));
      background: #0b0c10;
      color: #f2f4f8;
    }

    h2 { margin: 8px 4px 12px; font-size: 18px; font-weight: 700; }

    .app { display: grid; gap: 12px; }

    .panel {
      background: #12141b;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
    }

    .panelTitle { font-size: 13px; opacity: 0.85; margin-bottom: 8px; }

    .stack {
      position: relative;
      width: 100%;
      border-radius: var(--radius);
      overflow: hidden;
      background: #000;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: var(--radius);
      background: #000;
    }

    #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .status {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.85;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .download {
      display: inline-block;
      margin-top: 10px;
      font-size: 14px;
      color: #9ad1ff;
      text-decoration: none;
    }
    .download:active { opacity: 0.7; }

    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: rgba(10,12,16,0.92);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,0.08);
    }

    .buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    button {
      padding: 14px 12px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: #1b2130;
      color: #fff;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled { opacity: 0.45; }

    .sliders {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items: end;
    }

    label { display: grid; gap: 6px; font-size: 12px; opacity: 0.9; }

    input[type="number"] {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f1320;
      color: #fff;
      font-size: 14px;
      box-sizing: border-box;
    }

    .toggleRow {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      opacity: 0.9;
      user-select: none;
    }

    .hint { font-size: 12px; opacity: 0.75; margin-top: 8px; line-height: 1.4; }

    @media (min-width: 900px) {
      .app { grid-template-columns: 1fr 1fr; align-items: start; }
    }
  </style>
</head>

<body>
  <h2>Pose検知→スイング区間切り出し（iPhone単体）</h2>

  <div class="app">
    <section class="panel">
      <div class="stack">
        <video id="cam" playsinline autoplay muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="toggleRow">
        <input id="showOverlay" type="checkbox" checked />
        <label for="showOverlay" style="display:inline; gap:0; opacity:1;">オーバーレイ表示</label>
      </div>
      <div id="status" class="status">Ready</div>
      <div class="hint">※ オーバーレイをOFFにすると軽くなります（推定は継続）。</div>
    </section>

    <section class="panel">
      <div class="panelTitle">Replay（次の検知までループ）</div>
      <video id="replay" playsinline controls loop></video>
      <a id="download" class="download" style="display:none">クリップを保存</a>
      <div class="hint">検知した区間（PRE+POST秒）をここで自動ループ再生します。</div>
    </section>
  </div>

  <div class="controls">
    <div class="buttons">
      <button id="start">開始</button>
      <button id="stop" disabled>停止</button>
    </div>

    <div class="sliders">
      <label>PRE(s)
        <input id="pre" type="number" step="0.1" value="2.0">
      </label>
      <label>POST(s)
        <input id="post" type="number" step="0.1" value="2.0">
      </label>
      <label>閾値(SPEED)
        <input id="th" type="number" step="0.001" value="0.020">
      </label>
    </div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";

    const cam = document.getElementById("cam");
    const replay = document.getElementById("replay");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const downloadA = document.getElementById("download");

    const preEl = document.getElementById("pre");
    const postEl = document.getElementById("post");
    const thEl = document.getElementById("th");

    const startBtn = document.getElementById("start");
    const stopBtn = document.getElementById("stop");
    const showOverlayEl = document.getElementById("showOverlay");

    let stream = null;
    let poseLandmarker = null;
    let drawingUtils = null;

    // ---- MediaRecorder リングバッファ（時間付き）----
    let recorder = null;
    let ring = []; // { blob, start, end }
    let recordingPost = false;

    // ★MP4の再生に必要な init segment を保持
    let initChunk = null;

    // ★トリガー時刻 t0 と、チャンク境界推定用
    let triggerMs = 0;
    let lastChunkEndMs = 0;

    const SLICE_MS = 200;

    // ---- スイング判定用（とりあえず右手首速度のまま）----
    let lastWrist = null;
    let lastTs = 0;
    let cooldownUntil = 0;
    const COOLDOWN_MS = 1500;

    function log(s) { statusEl.textContent = s; }

    function pickMimeType() {
      const candidates = [
        "video/mp4",
        'video/mp4;codecs="avc1.42E01E,mp4a.40.2"',
      ];
      for (const mt of candidates) {
        try {
          if (window.MediaRecorder && MediaRecorder.isTypeSupported(mt)) return mt;
        } catch {}
      }
      return "";
    }

    function startRecorder(srcStream) {
      if (!window.MediaRecorder) {
        log("MediaRecorder is not supported on this browser.");
        return;
      }

      const mt = pickMimeType();
      const opts = mt ? { mimeType: mt } : undefined;

      try {
        recorder = new MediaRecorder(srcStream, opts);
      } catch (e) {
        console.error(e);
        log("MediaRecorder init failed: " + e.message);
        return;
      }

      initChunk = null;
      lastChunkEndMs = 0;

      recorder.onstart = () => log(`Recorder started (mime=${recorder.mimeType || "default"})`);
      recorder.onerror = (e) => log("Recorder error: " + (e?.error?.message || e?.message || "unknown"));

      recorder.ondataavailable = (e) => {
        if (!e.data || e.data.size === 0) return;

        if (!initChunk) initChunk = e.data;

        const end = performance.now();
        const start = lastChunkEndMs || (end - SLICE_MS); // 初回は近似
        lastChunkEndMs = end;

        ring.push({ blob: e.data, start, end });

        // ★トリガー前後に必要な分を残す（preだけ残すと“トリガー基準”で切れない）
        const PRE_SEC = parseFloat(preEl.value || "2.0");
        const POST_SEC = parseFloat(postEl.value || "2.0");
        const keepMs = (PRE_SEC + POST_SEC) * 1000 + 1500; // 余裕1.5s

        while (ring.length && (end - ring[0].end) > keepMs) ring.shift();

        // ★post待ち：t0+POST を過ぎたら確定
        if (recordingPost) {
          const until = triggerMs + POST_SEC * 1000;
          if (end >= until) {
            recordingPost = false;
            finalizeClip();
          }
        }

        // 進捗ログ（必要なければコメントアウト）
        // log(`chunk ${(e.data.size/1024).toFixed(1)}KB ring=${ring.length} post=${recordingPost}`);
      };

      recorder.start(SLICE_MS);
    }

    async function finalizeClip() {
      const PRE_SEC = parseFloat(preEl.value || "2.0");
      const POST_SEC = parseFloat(postEl.value || "2.0");

      const t0 = triggerMs;
      const from = t0 - PRE_SEC * 1000;
      const to   = t0 + POST_SEC * 1000;

      // ★[from,to] と重なるチャンクだけ集める
      const picked = ring.filter(ch => ch.end >= from && ch.start <= to);

      const mime = recorder?.mimeType || "video/mp4";
      const isMp4 = (mime || "").includes("mp4");

      const bodyChunks = picked.map(x => x.blob);
      const chunks = (isMp4 && initChunk) ? [initChunk, ...bodyChunks] : bodyChunks;

      const blob = new Blob(chunks, { type: mime });

      log(`finalize: picked=${picked.length} blob=${(blob.size/1024/1024).toFixed(2)}MB`);

      if (blob.size < 50 * 1024) {
        log("Clip too small. (record data not ready?)");
        return;
      }

      playClip(blob);

      // 本番では送信するならここを sendClip(blob) に置換
      restartRecorder();
    }

    function restartRecorder() {
      if (!recorder) return;

      try { recorder.stop(); } catch (e) { console.warn("recorder stop failed", e); }

      recorder = null;
      ring = [];
      initChunk = null;
      recordingPost = false;
      lastChunkEndMs = 0;

      setTimeout(() => {
        if (stream) {
          startRecorder(stream);
          log("Recorder restarted for next swing");
        }
      }, 100);
    }

    function playClip(blob) {
      if (replay.src) {
        try { URL.revokeObjectURL(replay.src); } catch {}
      }

      const url = URL.createObjectURL(blob);
      replay.src = url;
      replay.loop = true;
      replay.muted = true;
      replay.playsInline = true;

      replay.onloadeddata = () => log("Replay loadeddata");
      replay.onplay = () => log("Replay play");
      replay.onerror = () => log("Replay error");

      const p = replay.play();
      if (p) {
        p.catch(err => {
          console.warn(err);
          log("Replay play blocked: " + (err?.message || "tap replay once"));
        });
      }

      downloadA.href = url;
      downloadA.download = `swing_clip_${Date.now()}.mp4`;
      downloadA.style.display = "inline";
      downloadA.textContent = `クリップを保存（${(blob.size / 1024 / 1024).toFixed(2)}MB）`;
    }

    // ★トリガー時刻 t0 を保存して post待ちに入る
    function onSwingDetected() {
      if (recordingPost) return;

      const PRE_SEC = parseFloat(preEl.value || "2.0");
      const POST_SEC = parseFloat(postEl.value || "2.0");

      triggerMs = performance.now(); // ★t0
      recordingPost = true;

      log(`Swing detected! cut [${PRE_SEC}s, ${POST_SEC}s] around t0`);
    }

    function maybeTriggerSwing(landmarks, tsMs) {
      if (tsMs < cooldownUntil) return;

      const SPEED_TH = parseFloat(thEl.value || "0.02");
      const RIGHT_WRIST = 16;

      const w = landmarks[RIGHT_WRIST];
      if (!w) return;

      if (lastWrist && lastTs) {
        const dx = w.x - lastWrist.x;
        const dy = w.y - lastWrist.y;
        const dt = (tsMs - lastTs) / 1000;
        const speed = Math.sqrt(dx*dx + dy*dy) / Math.max(dt, 1e-3);

        if (speed > SPEED_TH) {
          cooldownUntil = tsMs + COOLDOWN_MS;
          onSwingDetected();
        }
      }

      lastWrist = { x: w.x, y: w.y };
      lastTs = tsMs;
    }

    let rafId = 0;
    function loop() {
      if (!poseLandmarker || cam.readyState < 2) {
        rafId = requestAnimationFrame(loop);
        return;
      }

      if (canvas.width !== cam.videoWidth) {
        canvas.width = cam.videoWidth;
        canvas.height = cam.videoHeight;
      }

      const t = performance.now();
      const res = poseLandmarker.detectForVideo(cam, t);

      const showOverlay = !!showOverlayEl?.checked;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (showOverlay) {
        ctx.drawImage(cam, 0, 0, canvas.width, canvas.height);
      }

      if (res.landmarks?.length) {
        const lm = res.landmarks[0];
        maybeTriggerSwing(lm, t);

        if (showOverlay) {
          drawingUtils.drawLandmarks(lm);
        }
      }

      rafId = requestAnimationFrame(loop);
    }

    async function initPose() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );

      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://tomoki-ishikawa32.github.io/iPhone_pose_test/models/pose_landmarker_lite.task"
        },
        runningMode: "VIDEO",
        numPoses: 1
      });

      drawingUtils = new DrawingUtils(ctx);
    }

    async function start() {
      startBtn.disabled = true;
      stopBtn.disabled = false;

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" }, // DLTなら "environment" 推奨
        audio: false
      });

      cam.srcObject = stream;
      await cam.play();

      await initPose();
      startRecorder(stream);

      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(loop);

      log("Started.");
    }

    function stop() {
      startBtn.disabled = false;
      stopBtn.disabled = true;

      cancelAnimationFrame(rafId);

      try {
        if (recorder && recorder.state !== "inactive") recorder.stop();
      } catch {}
      recorder = null;

      ring = [];
      initChunk = null;
      recordingPost = false;
      triggerMs = 0;
      lastChunkEndMs = 0;

      if (stream) {
        for (const tr of stream.getTracks()) tr.stop();
      }
      stream = null;

      cam.srcObject = null;
      log("Stopped.");
    }

    startBtn.onclick = () => start().catch(e => {
      console.error(e);
      log("Error: " + e.message);
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });

    stopBtn.onclick = stop;
  </script>
</body>
</html>
