<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>iPhone Pose Swing Clip</title>
  <style>
    :root {
      --radius: 14px;
      --pad: 12px;
    }

    body {
      font-family: -apple-system, system-ui, sans-serif;
      margin: 0;
      padding: 12px 12px calc(150px + env(safe-area-inset-bottom));
      background: #0b0c10;
      color: #f2f4f8;
    }

    h2 {
      margin: 8px 4px 12px;
      font-size: 18px;
      font-weight: 700;
    }

    .app {
      display: grid;
      gap: 12px;
    }

    .panel {
      background: #12141b;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
    }

    .panelTitle {
      font-size: 13px;
      opacity: 0.85;
      margin-bottom: 8px;
    }

    .stack {
      position: relative;
      width: 100%;
      border-radius: var(--radius);
      overflow: hidden;
      background: #000;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: var(--radius);
      background: #000;
    }

    #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .status {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.85;
      word-break: break-word;
    }

    .download {
      display: inline-block;
      margin-top: 10px;
      font-size: 14px;
      color: #9ad1ff;
      text-decoration: none;
    }
    .download:active { opacity: 0.7; }

    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: rgba(10,12,16,0.92);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,0.08);
    }

    .buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    button {
      padding: 14px 12px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: #1b2130;
      color: #fff;
      -webkit-tap-highlight-color: transparent;
    }

    button:disabled { opacity: 0.45; }

    .sliders {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items: end;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 12px;
      opacity: 0.9;
    }

    input[type="number"] {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f1320;
      color: #fff;
      font-size: 14px;
      box-sizing: border-box;
    }

    .toggleRow {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      opacity: 0.9;
      user-select: none;
    }

    .hint {
      font-size: 12px;
      opacity: 0.75;
      margin-top: 8px;
      line-height: 1.4;
    }

    /* iPad/横向きなど幅が広いときは2カラム */
    @media (min-width: 900px) {
      .app {
        grid-template-columns: 1fr 1fr;
        align-items: start;
      }
    }
  </style>
</head>

<body>
  <h2>Pose検知→スイング区間切り出し（iPhone単体）</h2>

  <div class="app">
    <section class="panel">
      <div class="stack">
        <video id="cam" playsinline autoplay muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="toggleRow">
        <input id="showOverlay" type="checkbox" checked />
        <label for="showOverlay" style="display:inline; gap:0; opacity:1;">オーバーレイ表示</label>
      </div>
      <div id="status" class="status">Ready</div>
      <div class="hint">※ オーバーレイをOFFにすると軽くなります（推定は継続）。</div>
    </section>

    <section class="panel">
      <div class="panelTitle">Replay（次の検知までループ）</div>
      <video id="replay" playsinline controls loop></video>
      <a id="download" class="download" style="display:none">クリップを保存</a>
      <div class="hint">検知した区間（PRE+POST秒）をここで自動ループ再生します。</div>
    </section>
  </div>

  <div class="controls">
    <div class="buttons">
      <button id="start">開始</button>
      <button id="stop" disabled>停止</button>
    </div>

    <div class="sliders">
      <label>PRE(s)
        <input id="pre" type="number" step="0.1" value="2.0">
      </label>
      <label>POST(s)
        <input id="post" type="number" step="0.1" value="2.0">
      </label>
      <label>閾値(SPEED)
        <input id="th" type="number" step="0.001" value="0.020">
      </label>
    </div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";

    const cam = document.getElementById("cam");
    const replay = document.getElementById("replay");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const downloadA = document.getElementById("download");

    const preEl = document.getElementById("pre");
    const postEl = document.getElementById("post");
    const thEl = document.getElementById("th");

    const startBtn = document.getElementById("start");
    const stopBtn = document.getElementById("stop");
    const showOverlayEl = document.getElementById("showOverlay");

    let stream = null;
    let poseLandmarker = null;
    let drawingUtils = null;

    // ---- MediaRecorder リングバッファ ----
    let recorder = null;
    let ring = [];              // {blob, t}
    let frozenPre = null;       // トリガー時点のpre確保
    let recordingPost = false;
    let postUntil = 0;

    const SLICE_MS = 200;       // 200msごとにチャンク生成（小さすぎると重い / 大きすぎると切り出しが粗い）

    // ---- スイング判定用 ----
    let lastWrist = null;
    let lastTs = 0;
    let cooldownUntil = 0;
    const COOLDOWN_MS = 1500;

    function log(s) { statusEl.textContent = s; }

    function pickMimeType() {
      // iOS Safariは isTypeSupported が false でも“指定しないと動く”ことがあるので、最後は "" を返す
      const candidates = [
        "video/mp4",
        'video/mp4;codecs="avc1.42E01E,mp4a.40.2"',
      ];
      for (const mt of candidates) {
        try {
          if (window.MediaRecorder && MediaRecorder.isTypeSupported(mt)) return mt;
        } catch {}
      }
      return "";
    }

    function startRecorder(srcStream) {
      const mt = pickMimeType();
      const opts = mt ? { mimeType: mt } : undefined;

      recorder = new MediaRecorder(srcStream, opts);

      recorder.ondataavailable = (e) => {
        if (!e.data || e.data.size === 0) return;
        const now = performance.now();
        ring.push({ blob: e.data, t: now });

        // pre秒ぶん維持（トリガー待ち中のみ古いのを捨てる）
        const PRE_SEC = parseFloat(preEl.value || "2.0");
        const keepMs = PRE_SEC * 1000 + SLICE_MS * 2;
        if (!recordingPost) {
          while (ring.length && (now - ring[0].t) > keepMs) ring.shift();
        }

        // post録画中：時間が来たら確定
        if (recordingPost && now >= postUntil) {
          recordingPost = false;
          finalizeClip();
        }
      };

      recorder.start(SLICE_MS);
      log(`Recorder started (mime=${recorder.mimeType || "default"})`);
    }

    async function finalizeClip() {
      // frozenPre + post期間を合成
      const PRE = frozenPre || [];
      frozenPre = null;

      const POST_SEC = parseFloat(postEl.value || "2.0");
      const now = performance.now();
      const post = ring.filter(x => (now - x.t) <= (POST_SEC * 1000 + SLICE_MS * 2));

      const chunks = [...PRE.map(x => x.blob), ...post.map(x => x.blob)];
      const blob = new Blob(chunks, { type: recorder.mimeType || "video/mp4" });

      // 次のpre用に、直近だけ残してもOK（ここではpost分だけ残す）
      ring = post.slice();

      playClip(blob);
    }

    function playClip(blob) {
      // 既存URL解放（blob URL）
      if (replay.src) {
        try { URL.revokeObjectURL(replay.src); } catch {}
      }

      const url = URL.createObjectURL(blob);
      replay.src = url;
      replay.loop = true;
      replay.play().catch(() => {});

      downloadA.href = url;
      downloadA.download = `swing_clip_${Date.now()}.mp4`; // 拡張子は目安（実際のmimeに依存）
      downloadA.style.display = "inline";
      downloadA.textContent = `クリップを保存（${(blob.size / 1024 / 1024).toFixed(2)}MB）`;

      log("Clip updated & looping.");
    }

    function onSwingDetected() {
      if (recordingPost) return;

      const PRE_SEC = parseFloat(preEl.value || "2.0");
      const POST_SEC = parseFloat(postEl.value || "2.0");

      frozenPre = ring.slice(); // pre確保
      recordingPost = true;
      postUntil = performance.now() + POST_SEC * 1000;

      log(`Swing detected! capture: pre=${PRE_SEC}s post=${POST_SEC}s`);
    }

    function maybeTriggerSwing(landmarks, tsMs) {
      // 右手首の速度（雑）でトリガー
      if (tsMs < cooldownUntil) return;

      const SPEED_TH = parseFloat(thEl.value || "0.02");
      const RIGHT_WRIST = 16;

      const w = landmarks[RIGHT_WRIST];
      if (!w) return;

      if (lastWrist && lastTs) {
        const dx = w.x - lastWrist.x;
        const dy = w.y - lastWrist.y;
        const dt = (tsMs - lastTs) / 1000;
        const speed = Math.sqrt(dx * dx + dy * dy) / Math.max(dt, 1e-3);

        if (speed > SPEED_TH) {
          cooldownUntil = tsMs + COOLDOWN_MS;
          onSwingDetected();
        }
      }

      lastWrist = { x: w.x, y: w.y };
      lastTs = tsMs;
    }

    let rafId = 0;
    function loop() {
      if (!poseLandmarker || cam.readyState < 2) {
        rafId = requestAnimationFrame(loop);
        return;
      }

      // canvasサイズ同期（videoが読めた後に確定）
      if (canvas.width !== cam.videoWidth) {
        canvas.width = cam.videoWidth;
        canvas.height = cam.videoHeight;
      }

      const t = performance.now();
      const res = poseLandmarker.detectForVideo(cam, t);

      const showOverlay = !!showOverlayEl?.checked;

      if (showOverlay) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(cam, 0, 0, canvas.width, canvas.height);
      } else {
        // 非表示時は描画コストを削減（透明にする）
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      if (res.landmarks?.length) {
        const lm = res.landmarks[0];

        // 閾値判定（推定は常に行う）
        maybeTriggerSwing(lm, t);

        // デバッグ描画
        if (showOverlay) {
          drawingUtils.drawLandmarks(lm);
        }
      }

      rafId = requestAnimationFrame(loop);
    }

    async function initPose() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );

      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://tomoki-ishikawa32.github.io/iPhone_pose_test/models/pose_landmarker_lite.task"
        },
        runningMode: "VIDEO",
        numPoses: 1
      });

      drawingUtils = new DrawingUtils(ctx);
    }

    async function start() {
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // カメラ開始
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" }, // 後方カメラなら "environment"
        audio: false
      });

      cam.srcObject = stream;
      await cam.play();

      // Pose初期化
      await initPose();

      // Recorder開始（カメラの同じstreamを録画）
      startRecorder(stream);

      // ループ開始
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(loop);

      log("Started.");
    }

    function stop() {
      startBtn.disabled = false;
      stopBtn.disabled = true;

      cancelAnimationFrame(rafId);

      if (recorder && recorder.state !== "inactive") recorder.stop();
      recorder = null;
      ring = [];
      frozenPre = null;
      recordingPost = false;

      if (stream) {
        for (const tr of stream.getTracks()) tr.stop();
      }
      stream = null;

      cam.srcObject = null;
      log("Stopped.");
    }

    startBtn.onclick = () => start().catch(e => {
      console.error(e);
      log("Error: " + e.message);
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });

    stopBtn.onclick = stop;
  </script>
</body>
</html>
