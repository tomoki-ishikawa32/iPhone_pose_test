<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>iPhone Pose Swing Clip</title>
  <style>
    :root { --radius: 14px; --pad: 12px; }

    body {
      font-family: -apple-system, system-ui, sans-serif;
      margin: 0;
      padding: 12px 12px calc(150px + env(safe-area-inset-bottom));
      background: #0b0c10;
      color: #f2f4f8;
    }

    h2 { margin: 8px 4px 12px; font-size: 18px; font-weight: 700; }

    .app { display: grid; gap: 12px; }

    .panel {
      background: #12141b;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
    }

    .panelTitle { font-size: 13px; opacity: 0.85; margin-bottom: 8px; }

    .stack {
      position: relative;
      width: 100%;
      border-radius: var(--radius);
      overflow: hidden;
      background: #000;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: var(--radius);
      background: #000;
    }

    #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .status {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.85;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .download {
      display: inline-block;
      margin-top: 10px;
      font-size: 14px;
      color: #9ad1ff;
      text-decoration: none;
    }
    .download:active { opacity: 0.7; }

    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: rgba(10,12,16,0.92);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,0.08);
    }

    .buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    button {
      padding: 14px 12px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: #1b2130;
      color: #fff;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled { opacity: 0.45; }

    .sliders {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items: end;
    }

    label { display: grid; gap: 6px; font-size: 12px; opacity: 0.9; }

    input[type="number"] {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f1320;
      color: #fff;
      font-size: 14px;
      box-sizing: border-box;
    }

    .toggleRow {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      opacity: 0.9;
      user-select: none;
    }

    .hint { font-size: 12px; opacity: 0.75; margin-top: 8px; line-height: 1.4; }

    @media (min-width: 900px) {
      .app { grid-template-columns: 1fr 1fr; align-items: start; }
    }
  </style>
</head>

<body>
  <h2>Pose検知→スイング区間切り出し（iPhone単体）</h2>

  <div class="app">
    <section class="panel">
      <div class="stack">
        <video id="cam" playsinline autoplay muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="toggleRow">
        <input id="showOverlay" type="checkbox" checked />
        <label for="showOverlay" style="display:inline; gap:0; opacity:1;">オーバーレイ表示</label>
      </div>
      <div id="status" class="status">Ready</div>
      <div class="hint">※ オーバーレイをOFFにすると軽くなります（推定は継続）。</div>
    </section>

    <section class="panel">
      <div class="panelTitle">Replay（次の検知までループ）</div>
      <video id="replay" playsinline controls loop></video>
      <a id="download" class="download" style="display:none">クリップを保存</a>
      <div class="hint">検知した区間（PRE+POST秒）をここで自動ループ再生します。</div>
    </section>
  </div>

  <div class="controls">
    <div class="buttons">
      <button id="start">開始</button>
      <button id="stop" disabled>停止</button>
    </div>

    <div class="sliders">
      <label>PRE(s)
        <input id="pre" type="number" step="0.1" value="2.0">
      </label>
      <label>POST(s)
        <input id="post" type="number" step="0.1" value="2.0">
      </label>
      <label>閾値(SPEED)
        <input id="th" type="number" step="0.001" value="0.020">
      </label>
    </div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";

    const cam = document.getElementById("cam");
    const replay = document.getElementById("replay");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const downloadA = document.getElementById("download");

    const preEl = document.getElementById("pre");
    const postEl = document.getElementById("post");
    const thEl = document.getElementById("th");

    const startBtn = document.getElementById("start");
    const stopBtn = document.getElementById("stop");
    const showOverlayEl = document.getElementById("showOverlay");

    let stream = null;
    let poseLandmarker = null;
    let drawingUtils = null;

    // ---- MediaRecorder リングバッファ ----
    let recorder = null;
    let ring = [];              // {blob, t}
    let frozenPre = null;       // トリガー時点のpre確保
    let recordingPost = false;
    let postUntil = 0;

    // ★追加：MP4再生に必要な“最初のチャンク”(init segment)を保持
    let initChunk = null;

    const SLICE_MS = 200;

    // ---- スイング判定用 ----
    let lastWrist = null;
    let lastTs = 0;
    let cooldownUntil = 0;
    const COOLDOWN_MS = 1500;

    function log(s) {
      // 画面に履歴っぽく出したいなら、下の1行を statusEl.textContent = s; から変更してOK
      statusEl.textContent = s;
    }

    function pickMimeType() {
      const candidates = [
        "video/mp4",
        'video/mp4;codecs="avc1.42E01E,mp4a.40.2"',
      ];
      for (const mt of candidates) {
        try {
          if (window.MediaRecorder && MediaRecorder.isTypeSupported(mt)) return mt;
        } catch {}
      }
      return "";
    }

    // ★差し替え：診断ログ入り + initChunk保持 + エラーハンドリング
    function startRecorder(srcStream) {
      if (!window.MediaRecorder) {
        log("MediaRecorder is not supported on this browser.");
        return;
      }

      const mt = pickMimeType();
      const opts = mt ? { mimeType: mt } : undefined;

      try {
        recorder = new MediaRecorder(srcStream, opts);
      } catch (e) {
        console.error(e);
        log("MediaRecorder init failed: " + e.message);
        return;
      }

      initChunk = null; // ★毎回リセット

      recorder.onstart = () => log(`Recorder started (mime=${recorder.mimeType || "default"})`);
      recorder.onerror = (e) => log("Recorder error: " + (e?.error?.message || e?.message || "unknown"));

      recorder.ondataavailable = (e) => {
        if (!e.data || e.data.size === 0) return;

        // ★最初のチャンクを保持（MP4の再生に必要なことが多い）
        if (!initChunk) initChunk = e.data;

        const now = performance.now();
        ring.push({ blob: e.data, t: now });

        // ★診断：チャンクサイズ＆状態（必要ならコメントアウト）
        log(`chunk: ${(e.data.size/1024).toFixed(1)} KB | ring=${ring.length} | post=${recordingPost}`);

        const PRE_SEC = parseFloat(preEl.value || "2.0");
        const keepMs = PRE_SEC * 1000 + SLICE_MS * 2;
        if (!recordingPost) {
          while (ring.length && (now - ring[0].t) > keepMs) ring.shift();
        }

        if (recordingPost && now >= postUntil) {
          recordingPost = false;
          finalizeClip();
        }
      };

      recorder.start(SLICE_MS);
    }

    // ★差し替え：initChunkを先頭に足す + サイズ診断
    async function finalizeClip() {
      const PRE = frozenPre || [];
      frozenPre = null;

      const POST_SEC = parseFloat(postEl.value || "2.0");
      const now = performance.now();
      const post = ring.filter(x => (now - x.t) <= (POST_SEC * 1000 + SLICE_MS * 2));

      const bodyChunks = [...PRE.map(x => x.blob), ...post.map(x => x.blob)];

      const mime = recorder?.mimeType || "video/mp4";
      const isMp4 = (mime || "").includes("mp4");
      const chunks = (isMp4 && initChunk) ? [initChunk, ...bodyChunks] : bodyChunks;

      const blob = new Blob(chunks, { type: mime });

      // 次のpre用にpost分だけ残す
      ring = post.slice();

      log(`finalize: chunks=${chunks.length} blob=${(blob.size/1024/1024).toFixed(2)}MB type=${blob.type}`);

      if (blob.size < 50 * 1024) {
        log("Clip too small. MediaRecorder may not be producing playable data.");
        return;
      }

      playClip(blob);
    }

    // ★差し替え：iOS対策（muted等）+ ログ + playブロック検知
    function playClip(blob) {
      if (replay.src) {
        try { URL.revokeObjectURL(replay.src); } catch {}
      }

      const url = URL.createObjectURL(blob);
      replay.src = url;
      replay.loop = true;
      replay.muted = true;     // ★自動再生を通しやすくする
      replay.playsInline = true;

      replay.onloadeddata = () => log("Replay loadeddata");
      replay.onplay = () => log("Replay play");
      replay.onerror = () => log("Replay error");

      const p = replay.play();
      if (p) {
        p.catch(err => {
          console.warn(err);
          log("Replay play blocked: " + (err?.message || "tap replay once"));
        });
      }

      downloadA.href = url;
      downloadA.download = `swing_clip_${Date.now()}.mp4`;
      downloadA.style.display = "inline";
      downloadA.textContent = `クリップを保存（${(blob.size / 1024 / 1024).toFixed(2)}MB）`;
    }

    function onSwingDetected() {
      log("Swing detected! (waiting post...)");
      if (recordingPost) return;

      const PRE_SEC = parseFloat(preEl.value || "2.0");
      const POST_SEC = parseFloat(postEl.value || "2.0");

      frozenPre = ring.slice();
      recordingPost = true;
      postUntil = performance.now() + POST_SEC * 1000;

      log(`Swing detected! capture: pre=${PRE_SEC}s post=${POST_SEC}s`);
    }

    function maybeTriggerSwing(landmarks, tsMs) {
      if (tsMs < cooldownUntil) return;

      const SPEED_TH = parseFloat(thEl.value || "0.02");
      const RIGHT_WRIST = 16;

      const w = landmarks[RIGHT_WRIST];
      if (!w) return;

      if (lastWrist && lastTs) {
        const dx = w.x - lastWrist.x;
        const dy = w.y - lastWrist.y;
        const dt = (tsMs - lastTs) / 1000;
        const speed = Math.sqrt(dx * dx + dy * dy) / Math.max(dt, 1e-3);

        if (speed > SPEED_TH) {
          cooldownUntil = tsMs + COOLDOWN_MS;
          onSwingDetected();
        }
      }

      lastWrist = { x: w.x, y: w.y };
      lastTs = tsMs;
    }

    let rafId = 0;
    function loop() {
      if (!poseLandmarker || cam.readyState < 2) {
        rafId = requestAnimationFrame(loop);
        return;
      }

      if (canvas.width !== cam.videoWidth) {
        canvas.width = cam.videoWidth;
        canvas.height = cam.videoHeight;
      }

      const t = performance.now();
      const res = poseLandmarker.detectForVideo(cam, t);

      const showOverlay = !!showOverlayEl?.checked;

      if (showOverlay) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(cam, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      if (res.landmarks?.length) {
        const lm = res.landmarks[0];
        maybeTriggerSwing(lm, t);

        if (showOverlay) {
          drawingUtils.drawLandmarks(lm);
        }
      }

      rafId = requestAnimationFrame(loop);
    }

    async function initPose() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );

      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://tomoki-ishikawa32.github.io/iPhone_pose_test/models/pose_landmarker_lite.task"
        },
        runningMode: "VIDEO",
        numPoses: 1
      });

      drawingUtils = new DrawingUtils(ctx);
    }

    async function start() {
      startBtn.disabled = true;
      stopBtn.disabled = false;

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" }, // 後方カメラなら "environment"
        audio: false
      });

      cam.srcObject = stream;
      await cam.play();

      await initPose();
      startRecorder(stream);

      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(loop);

      log("Started.");
    }

    function stop() {
      startBtn.disabled = false;
      stopBtn.disabled = true;

      cancelAnimationFrame(rafId);

      if (recorder && recorder.state !== "inactive") recorder.stop();
      recorder = null;

      ring = [];
      frozenPre = null;
      recordingPost = false;
      initChunk = null; // ★追加

      if (stream) {
        for (const tr of stream.getTracks()) tr.stop();
      }
      stream = null;

      cam.srcObject = null;
      log("Stopped.");
    }

    startBtn.onclick = () => start().catch(e => {
      console.error(e);
      log("Error: " + e.message);
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });

    stopBtn.onclick = stop;
  </script>
</body>
</html>
